// @flow

export type PluginApi<S> = {
  // Own (private) state
  state: S,
  // Set own (private) state
  setState: S => mixed,
  // Call public method of other plugin
  callPlugin: (methodName: string) => mixed,
  // Emit event that other plugins can listen to
  emitEvent: (eventName: string, eventParams: {}) => void
};

type InitialStateGetter<S> = () => S;

type Listener<S> = (PluginApi<S>, ...userParams: any) => mixed;

type Subscription<S> = (PluginApi<S>) => () => mixed;

type Method<S> = (PluginApi<S>, ...userParams: any) => any;

type InitialStateBlock<S> = {
  type: 'initialState',
  fn: InitialStateGetter<S>
};

type ListenerBlock<S> = {
  type: 'listener',
  eventName: string,
  fn: Listener<S>
};

type SubscriptionBlock<S> = {
  type: 'subscription',
  fn: Subscription<S>
};

type MethodBlock<S> = {
  type: 'method',
  name: string,
  fn: Method<S>
};

export type Blocks<S> = {
  initialState: InitialStateBlock<S>,
  listeners: Array<ListenerBlock<S>>,
  subscriptions: Array<SubscriptionBlock<S>>,
  methods: Array<MethodBlock<S>>
};

declare export function createInitialState<S>(
  InitialStateGetter<S>
): InitialStateBlock<S>;

declare export function createListener<S>(
  eventName: string,
  fn: Listener<S>
): ListenerBlock<S>;

declare export function createSubscription<S>(
  eventName: string,
  fn: Subscription<S>
): SubscriptionBlock<S>;

declare export function createMethod<S>(
  name: string,
  fn: Method<S>
): MethodBlock<S>;

declare export function registerPlugin<S>(
  name: string,
  blocks: Blocks<S>
): void;
