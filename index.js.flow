// @flow

export type PluginApi<S> = {
  // Own (private) state
  state: S,
  // Set own (private) state
  setState: S => mixed,
  // Call public method of other plugin
  callPlugin: (methodName: string) => mixed,
  // Emit event that other plugins can listen to
  emitEvent: (eventName: string, eventParams: {}) => void
};

// Function signatures

type InitialStateGetter<S> = () => S;

type Listener<S> = (PluginApi<S>, ...userParams: any) => mixed;

type Subscription<S> = (PluginApi<S>) => () => mixed;

type Method<S> = (PluginApi<S>, ...userParams: any) => any;

// Blocks

type InitialStateBlock<S> = {
  type: "initialState",
  fn: InitialStateGetter<S>
};

type ListenerBlock<S> = {
  type: "listener",
  eventName: string,
  fn: Listener<S>
};

type SubscriptionBlock<S> = {
  type: "subscription",
  fn: Subscription<S>
};

type MethodBlock<S> = {
  type: "method",
  name: string,
  fn: Method<S>
};

// Block creators

type InitialState<S> = (InitialStateGetter<S>) => InitialStateBlock<S>;

type CreateListener<S> = (
  eventName: string,
  fn: Listener<S>
) => ListenerBlock<S>;

type CreateSubscription<S> = (
  eventName: string,
  fn: Subscription<S>
) => SubscriptionBlock<S>;

type CreateMethod<S> = (name: string, fn: Method<S>) => MethodBlock<S>;

// Public API

export type Blocks<S> = {
  initialState: InitialState<S>,
  listeners: Array<ListenerBlock<S>>,
  subscriptions: Array<SubscriptionBlock<S>>,
  methods: Array<MethodBlock<S>>
};

export type RegisterPlugin<S> = (name: string, blocks: Blocks<S>) => void;
