// @flow
// tslint:disable

type StateUpdater<State> = State | ((prevState: State) => State);

export type IPluginDef<PluginConfig: {}, PluginState> = {
  name: string,
  enabled?: boolean,
  defaultConfig?: PluginConfig,
  initialState?: PluginState,
};

export type IPluginContext<PluginConfig: {}, PluginState> = {
  getConfig: () => PluginConfig,
  getConfigOf: (pluginName: string) => { [attr: string]: any },
  getState: () => PluginState,
  getStateOf: (pluginName: string) => any,
  setState: (change: StateUpdater<PluginState>, cb?: () => mixed) => void,
  callMethod: (methodPath: string, ...args: Array<any>) => any,
  emitEvent: (eventName: string, ...args: Array<any>) => void,
};

type InitHandler<PluginConfig: {}, PluginState> = (
  context: IPluginContext<PluginConfig, PluginState>,
) => void | (() => mixed);

type MethodHandler<PluginConfig: {}, PluginState> = (
  context: IPluginContext<PluginConfig, PluginState>,
  ...args: any[]
) => any;

// NOTE: "EventHandler" collides with a global type
type PluginEventHandler<PluginConfig: {}, PluginState> = (
  context: IPluginContext<PluginConfig, PluginState>,
  ...args: any[]
) => void;

export type IPlugin = {
  name: string,
  enabled: boolean,
  defaultConfig: {},
  initialState: any,
  initHandlers: Array<InitHandler<any, any>>,
  methodHandlers: Array<{
    methodName: string,
    handler: MethodHandler<any, any>,
  }>,
  eventHandlers: Array<{
    eventPath: string,
    handler: PluginEventHandler<any, any>,
  }>,
};

export type IPluginsByName = {
  [pluginName: string]: IPlugin,
};

export type IPluginApi<PluginConfig: {}, PluginState> = {
  init: (handler: InitHandler<PluginConfig, PluginState>) => void,
  method: (
    methodName: string,
    handler: MethodHandler<PluginConfig, PluginState>,
  ) => void,
  on: (
    eventPath: string,
    handler: PluginEventHandler<PluginConfig, PluginState>,
  ) => void,
};

type IPluginConfigs = {
  [pluginName: string]: { [attr: string]: any },
};

type IPluginStates = {
  [pluginName: string]: any,
};

type ILoadPluginsOpts = {
  config?: IPluginConfigs,
  state?: IPluginStates,
};

type PluginChangeHandler = (plugins: IPluginsById) => mixed;

type StateChangeHandler = () => mixed;

type UnloadHandlers = () => mixed;

type PluginScopeId = number;

type IPluginScope = {
  id: PluginScopeId,
  plugins: IPluginsByName,
  config: IPluginConfigs,
  state: IPluginStates,
  unloadHandlers: UnloadHandlers[],
  unload: () => void,
  reload: () => void,
  getPluginContext: (pluginName: string) => IPluginContext<any, any>,
};

declare export function resetPlugins(): void;

declare export function createPlugin(pluginDef: IPluginDef<any, any>): IPlugin;

declare export function getPluginApi<PluginConfig: {}, PluginState>(
  pluginName: string,
): IPluginApi<PluginConfig, PluginState>;

declare export function registerPlugin<PluginConfig: {}, PluginState>(
  pluginDef: IPluginDef<PluginConfig, PluginState>,
): IPluginApi<PluginConfig, PluginState>;

declare export function loadPlugins(opts?: ILoadPluginsOpts): void;

declare export function unloadPlugins(): void;

declare export function getPlugins(): IPluginsById;

declare export function onPluginChange(
  handler: PluginChangeHandler,
): () => void;

declare export function onStateChange(handler: StateChangeHandler): () => void;

declare export function getPluginContext(
  pluginName: string,
): IPluginContext<any, any>;

declare export function enablePlugin(
  pluginName: string,
  enabled: boolean,
): void;

declare export function getLoadedScope(): null | IPluginScope;

declare export function isPluginLoaded(plugin: IPlugin): boolean;
